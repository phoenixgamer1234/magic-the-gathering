<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MTG Deck Builder</title>
<style>
  body { font-family: Arial, sans-serif; margin: 14px; background: #f6f7f8; color: #111; }
  h1 { font-size: 22px; margin-bottom: 10px; }
  .layout { display: flex; gap: 16px; align-items: flex-start; }
  .col { background: #fff; border: 1px solid #e2e4e6; padding: 12px; border-radius: 10px; }
  .left { flex: 1; min-width: 360px; }
  .right { width: 400px; }
  #results { max-height: 60vh; overflow-y: auto; display: flex; flex-direction: column; gap: 8px; margin-top: 6px; }
  .result { display: flex; align-items: center; gap: 10px; padding: 8px; border-radius: 8px; border: 1px solid #eee; background: #fff; }
  .thumb { width: 48px; height: 70px; background: #f2f3f4; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 11px; color: #999; }
  .meta { flex: 1; }
  .meta small { display: block; color: #666; margin-top: 4px; }
  .deck-list, #importExportArea { max-height: 30vh; overflow-y: auto; margin-top: 6px; padding: 4px; border: 1px solid #ddd; border-radius: 6px; background: #fafafa; }
  .deck-row { display: flex; align-items: center; justify-content: space-between; gap: 8px; padding: 6px; border-bottom: 1px dashed #eee; }
  .count { background: #eee; padding: 4px 6px; border-radius: 4px; font-weight: 700; }
  #preview { margin-top: 12px; text-align: center; }
  #preview img { max-width: 100%; border-radius: 6px; display: block; margin: 6px auto; }
  button { cursor: pointer; padding: 4px 8px; border-radius: 6px; border: none; background: #287271; color: white; }
  button.alt { background: #444; }
  select, input[type=text], input[type=search] { padding: 6px; border-radius: 6px; border: 1px solid #ccc; }
  .muted { color: #666; font-size: 13px; }
</style>
</head>
<body>

<h1>MTG Deck Builder — Standard / Commander</h1>

<div class="layout">
  <main class="col left">
    <div class="controls">
      <input type="search" id="searchInput" placeholder="Card name / keyword">
      <button id="searchBtn">Search</button>
      <select id="formatSelect">
        <option value="standard">Standard</option>
        <option value="commander">Commander</option>
      </select>
      <button id="toggleFilters" class="alt">Show Filters</button>
    </div>

    <div id="filterPanel" style="display:none; margin-top: 8px;">
      <label>Type:
        <input type="text" id="typeFilter" placeholder="e.g., Creature">
      </label>
      <label>Supertype:
        <input type="text" id="supertypeFilter" placeholder="e.g., Legendary">
      </label>
      <label>Subtype:
        <input type="text" id="subtypeFilter" placeholder="e.g., Elf">
      </label>
      <label>Colors (comma separated, e.g., W,U):
        <input type="text" id="colorFilter" placeholder="W,U,R,B,G">
      </label>
    </div>

    <div id="results"><div class="muted">Search to see results</div></div>

    <div id="preview">
      <strong id="previewName">Preview</strong>
      <div id="previewType" class="muted"></div>
      <img id="previewImg" src="" alt="">
    </div>
  </main>

  <aside class="col right">
    <strong>Your Deck</strong>
    <div class="muted" style="margin-bottom: 4px;">Deck list with counts</div>
    <div id="deckList" class="deck-list"></div>

    <strong style="margin-top:12px; display:block;">Import / Export List</strong>
    <div class="muted" style="margin-bottom: 4px;">Plain list (Untap-style)</div>
    <textarea id="importExportArea" style="width:100%; height:150px;"></textarea>
  </aside>
</div>

<script>
const deckMap = {};
let deckOrder = [];

function updateDeckList() {
  const deckDiv = document.getElementById('deckList');
  deckDiv.innerHTML = '';
  let total = 0;
  deckOrder.forEach(id=>{
    const e = deckMap[id];
    total += e.count;
    const row = document.createElement('div');
    row.className = 'deck-row';
    row.innerHTML = `<span>${e.count} x ${e.card.name} (${e.card.type_line||''})</span>`;
    const btns = document.createElement('div');
    const plus = document.createElement('button'); plus.textContent = '+'; plus.onclick = ()=> addToDeck(e.card);
    const minus = document.createElement('button'); minus.textContent = '−'; minus.onclick = ()=> removeOne(id);
    btns.appendChild(plus); btns.appendChild(minus);
    row.appendChild(btns);
    deckDiv.appendChild(row);
  });
  updateImportExport();
}

function updateImportExport() {
  const text = deckOrder.map(id=>{
    const e = deckMap[id];
    return e.count + ' ' + e.card.name;
  }).join('\n');
  document.getElementById('importExportArea').value = text;
}

function addToDeck(card) {
  const format = document.getElementById('formatSelect').value;
  const id = card.id || ('local:' + card.name);
  if (!deckMap[id]) { deckMap[id] = { card: card, count: 0 }; deckOrder.push(id); }
  let cur = deckMap[id].count;
  // Rules enforcement
  if (format === 'standard' && cur >= 4) { alert('Standard: max 4 copies'); return; }
  if (format === 'commander' && cur >= 1 && !isBasicLand(card)) { alert('Commander: only 1 copy per card'); return; }
  if (format === 'standard' && totalDeckCount() >= 60) { alert('Standard: max 60 cards'); return; }
  if (format === 'commander' && totalDeckCount() >= 100) { alert('Commander: deck full'); return; }
  deckMap[id].count++;
  updateDeckList();
}

function removeOne(id) {
  if (!deckMap[id]) return;
  deckMap[id].count--;
  if (deckMap[id].count <=0) { delete deckMap[id]; deckOrder = deckOrder.filter(x=>x!==id); }
  updateDeckList();
}

function totalDeckCount() {
  return deckOrder.reduce((sum,id)=>sum + deckMap[id].count,0);
}

function isBasicLand(card) {
  return (card.type_line || '').toLowerCase().includes('basic land');
}

// Search & Filters
async function searchCards() {
  const q = document.getElementById('searchInput').value.trim() || 'a';
  let url = `https://api.scryfall.com/cards/search?q=${encodeURIComponent(q)}`;
  try {
    const res = await fetch(url);
    const data = await res.json();
    const results = (data.data || []).filter(c=>filterCard(c));
    renderSearchResults(results);
  } catch(e){ console.error(e); alert('Search failed'); }
}

function filterCard(c) {
  const typeF = document.getElementById('typeFilter').value.trim().toLowerCase();
  const superF = document.getElementById('supertypeFilter').value.trim().toLowerCase();
  const subF = document.getElementById('subtypeFilter').value.trim().toLowerCase();
  const colors = document.getElementById('colorFilter').value.trim().toUpperCase().split(',').filter(Boolean);
  if (typeF && !(c.type_line||'').toLowerCase().includes(typeF)) return false;
  if (superF && !(c.type_line||'').toLowerCase().includes(superF)) return false;
  if (subF && !((c.type_line||'').split('—')[1]||'').toLowerCase().includes(subF)) return false;
  if (colors.length) {
    const cardColors = c.colors || [];
    if (!colors.every(ch=>cardColors.includes(ch))) return false;
  }
  return true;
}

function renderSearchResults(entries) {
  const div = document.getElementById('results');
  div.innerHTML = '';
  if (!entries.length) { div.innerHTML = '<div class="muted">No results</div>'; return; }
  entries.forEach(c=>{
    const row = document.createElement('div'); row.className='result';
    const thumb = document.createElement('div'); thumb.className='thumb'; thumb.textContent = (c.set||'').toUpperCase();
    const meta = document.createElement('div'); meta.className='meta'; meta.innerHTML = `<strong>${c.name}</strong><small>${c.type_line||''}</small>`;
    const actions = document.createElement('div');
    const previewBtn = document.createElement('button'); previewBtn.textContent='Preview'; previewBtn.onclick = ()=> showPreview(c);
    const addBtn = document.createElement('button'); addBtn.textContent='Add'; addBtn.onclick = ()=> addToDeck(c);
    actions.appendChild(previewBtn); actions.appendChild(addBtn);
    row.appendChild(thumb); row.appendChild(meta); row.appendChild(actions);
    div.appendChild(row);
  });
}

function showPreview(c) {
  document.getElementById('previewName').textContent = c.name;
  document.getElementById('previewType').textContent = c.type_line || '';
  let img = c.image_uris?.normal || c.image_uris?.large || (c.card_faces && c.card_faces[0].image_uris?.normal) || '';
  const imgEl = document.getElementById('previewImg');
  if(img) { imgEl.src = img; imgEl.style.display='block'; } else { imgEl.style.display='none'; }
}

// Event Listeners
document.getElementById('searchBtn').addEventListener('click', searchCards);
document.getElementById('searchInput').addEventListener('keydown', e=>{ if(e.key==='Enter') searchCards(); });
document.getElementById('toggleFilters').addEventListener('click', ()=>{
  const f = document.getElementById('filterPanel');
  f.style.display = f.style.display==='none'?'block':'none';
});
</script>

</body>
</html>
