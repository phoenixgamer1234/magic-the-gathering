<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>MTG Deck Builder — Advanced Filters</title>
<style>
  :root{--accent:#287271;--muted:#666}
  body{font-family:Inter,Segoe UI,Arial,sans-serif;margin:14px;background:#f6f7f8;color:#111}
  header{display:flex;align-items:center;gap:12px;margin-bottom:10px}
  h1{font-size:20px;margin:0}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px}
  input[type="search"]{padding:8px 10px;border:1px solid #ccc;border-radius:8px;width:320px}
  button{background:var(--accent);color:#fff;border:0;padding:8px 12px;border-radius:8px;cursor:pointer}
  button.alt{background:#444}
  .layout{display:flex;gap:16px;align-items:flex-start}
  .col{background:#fff;border:1px solid #e2e4e6;padding:12px;border-radius:10px}
  .left{flex:1;min-width:360px}
  .right{width:380px}
  #results{max-height:64vh;overflow:auto;display:flex;flex-direction:column;gap:8px;padding-top:6px}
  .result{display:flex;align-items:center;gap:10px;padding:8px;border-radius:8px;border:1px solid #eee;background:#fff}
  .thumb{width:48px;height:70px;background:#f2f3f4;border-radius:4px;display:flex;align-items:center;justify-content:center;font-size:11px;color:#999}
  .meta{flex:1}
  .meta small{display:block;color:var(--muted);margin-top:4px}
  .deck-list{max-height:44vh;overflow:auto;margin-top:6px}
  .deck-row{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:8px;border-radius:6px;border-bottom:1px dashed #eee}
  .count{background:#eee;padding:6px 8px;border-radius:6px;font-weight:700}
  .preview{margin-top:12px;text-align:center}
  img#previewImg{max-width:100%;border-radius:8px;display:block;margin:0 auto}
  .muted{color:var(--muted);font-size:13px}
  textarea{width:100%;height:120px;border:1px solid #ddd;border-radius:8px;padding:8px}
  .row{display:flex;gap:8px;align-items:center}
  .filters{margin-top:10px;border-top:1px solid #eee;padding-top:10px}
  .filter-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:8px}
  select, input[type="text"]{padding:6px;border-radius:6px;border:1px solid #ccc}
  label.checkbox{display:flex;gap:6px;align-items:center}
  .small{font-size:13px;color:#444}
</style>
</head>
<body>
<header>
  <div>
    <h1>MTG Deck Builder — Advanced Filters</h1>
    <div class="muted">Toggle Advanced Filters to narrow results by type, subtype, supertypes, colors, and format.</div>
  </div>
</header>

<div class="controls">
  <input id="q" type="search" placeholder="Name / keyword (press Enter or Search)" />
  <button id="searchBtn">Search</button>
  <button id="toggleFilters" class="alt">Show Advanced Filters</button>
  <label style="display:flex;align-items:center;gap:8px;margin-left:8px">
    <input id="fourLimit" type="checkbox" checked /> Enforce 4-of
  </label>
  <div style="margin-left:auto" class="row">
    <button id="exportBtn">Export JSON</button>
    <button id="importBtn" class="alt">Import</button>
  </div>
</div>

<div class="layout">
  <main class="col left">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div><strong>Search results</strong> <span id="searchInfo" class="muted" style="margin-left:8px"></span></div>
      <div class="small muted">Results show first page; use Next/Prev to page.</div>
    </div>

    <div id="filterPanel" class="filters" style="display:none">
      <div class="filter-row">
        <div style="min-width:220px">
          <label class="small">Supertype</label>
          <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:6px">
            <label class="checkbox"><input type="checkbox" value="Legendary" class="suptype" /> Legendary</label>
            <label class="checkbox"><input type="checkbox" value="Basic" class="suptype" /> Basic</label>
            <label class="checkbox"><input type="checkbox" value="Snow" class="suptype" /> Snow</label>
          </div>
        </div>

        <div style="min-width:180px">
          <label class="small">Type</label>
          <select id="typeSelect">
            <option value="">Any</option>
            <option>Creature</option><option>Artifact</option><option>Enchantment</option><option>Instant</option>
            <option>Sorcery</option><option>Land</option><option>Planeswalker</option><option>Tribal</option>
          </select>
        </div>

        <div style="min-width:180px">
          <label class="small">Subtype (text)</label>
          <input id="subtypeInput" type="text" placeholder="e.g. Elf, Zombie" />
        </div>
      </div>

      <div class="filter-row">
        <div>
          <label class="small">Mana Colors (requires card include all selected)</label>
          <div style="display:flex;gap:8px;margin-top:6px">
            <label class="checkbox"><input type="checkbox" value="W" class="colorChk" /> W</label>
            <label class="checkbox"><input type="checkbox" value="U" class="colorChk" /> U</label>
            <label class="checkbox"><input type="checkbox" value="B" class="colorChk" /> B</label>
            <label class="checkbox"><input type="checkbox" value="R" class="colorChk" /> R</label>
            <label class="checkbox"><input type="checkbox" value="G" class="colorChk" /> G</label>
          </div>
        </div>

        <div style="min-width:220px">
          <label class="small">Format legality</label>
          <select id="formatSelect">
            <option value="">Any</option>
            <option value="standard">Standard</option>
            <option value="pioneer">Pioneer</option>
            <option value="modern">Modern</option>
            <option value="legacy">Legacy</option>
            <option value="vintage">Vintage</option>
            <option value="commander">Commander</option>
            <option value="pauper">Pauper</option>
            <option value="historic">Historic</option>
            <option value="brawl">Brawl</option>
          </select>
        </div>
      </div>

      <div style="display:flex;gap:8px;align-items:center;margin-top:6px">
        <button id="applyFilters" class="alt">Apply Filters (Search)</button>
        <button id="clearFilters">Clear Filters</button>
        <div class="muted small" style="margin-left:auto">Filters are applied client-side to Scryfall results.</div>
      </div>
    </div>

    <div id="results" aria-live="polite" style="margin-top:12px">
      <div class="muted">Search to see results.</div>
    </div>

    <div class="muted" style="margin-top:10px">Tip: If you leave the name field blank and apply filters, the app will search a broad term like "a" to fetch a page of cards and then filter client-side. You can use paging to see more.</div>
  </main>

  <aside class="col right">
    <div>
      <strong>Your Deck</strong>
      <div class="muted">Saved in your browser</div>
      <div id="deckCount" style="margin-top:8px;font-weight:700">0 cards</div>
    </div>

    <div id="deckArea" class="deck-list" aria-live="polite"></div>

    <div class="preview col" style="margin-top:10px">
      <strong id="previewTitle">Preview</strong>
      <div id="previewType" class="muted" style="margin-bottom:8px"></div>
      <img id="previewImg" alt="card preview" style="display:none;max-width:100%;border-radius:6px" />
      <div id="previewPlaceholder" class="muted">No card selected</div>
    </div>

    <div style="margin-top:12px" class="col">
      <strong>Import / Export</strong>
      <div class="muted">Copy/paste deck JSON or use the buttons.</div>
      <textarea id="jsonArea" placeholder='{"deck":[{"id":"...","name":"...","count":4}]}'></textarea>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="applyImport">Apply Import</button>
        <button id="copyExport" class="alt">Copy JSON</button>
      </div>
    </div>
  </aside>
</div>

<script>
/* Advanced-filter deck builder
   Strategy:
   - Search Scryfall (by name/keyword). If name empty, we search a broad single-letter 'a' to receive results.
   - Apply client-side filters: supertypes, type, subtype (from type_line), colors (card.colors array), and Scryfall legalities for the chosen format.
   - Uses fallback CORS proxy if direct fetch fails (same pattern as before).
*/

// Config
const LOCAL_KEY = 'gh_mtg_deck_v2';
const SRY_BASE = 'https://api.scryfall.com/cards/search?q=';
const CORS_PROXY = 'https://api.allorigins.win/raw?url=';
const MAX_RESULTS = 60;

// Deck storage
let deckMap = {}; let deckOrder = [];

function loadDeck(){
  try {
    const raw = localStorage.getItem(LOCAL_KEY);
    if (!raw) return;
    const parsed = JSON.parse(raw);
    if (Array.isArray(parsed.deck)){
      deckMap = {}; deckOrder = [];
      parsed.deck.forEach(it => {
        const id = it.id || ('local:' + it.name);
        deckMap[id] = { card:{ id:id, name:it.name, type_line: it.type_line||'', image_uris: it.image_uris||null }, count: it.count||1 };
        deckOrder.push(id);
      });
    }
  } catch(e){ console.warn(e); }
}

function saveDeck(){
  const arr = deckOrder.map(id => {
    const e = deckMap[id];
    return { id:e.card.id, name:e.card.name, count:e.count, type_line:e.card.type_line||'', image_uris:e.card.image_uris||null };
  });
  localStorage.setItem(LOCAL_KEY, JSON.stringify({deck:arr}));
  renderDeck();
}

function clearDeck(){
  if (!confirm('Clear deck from browser storage?')) return;
  localStorage.removeItem(LOCAL_KEY); deckMap = {}; deckOrder = []; renderDeck();
}

// Render deck
function renderDeck(){
  const area = document.getElementById('deckArea'); area.innerHTML = '';
  let total = 0;
  deckOrder.forEach(id=>{
    const e = deckMap[id]; if(!e) return;
    total += e.count;
    const row = document.createElement('div'); row.className = 'deck-row';
    const left = document.createElement('div'); left.innerHTML = `<div><strong>${escapeHtml(e.card.name)}</strong></div><div class="muted">${escapeHtml(e.card.type_line||'')}</div>`;
    const right = document.createElement('div'); right.style.display='flex'; right.style.gap='6px'; right.style.alignItems='center';
    const count = document.createElement('div'); count.className='count'; count.textContent = e.count;
    const plus = document.createElement('button'); plus.textContent='+'; plus.onclick = ()=> addToDeck(e.card);
    const minus = document.createElement('button'); minus.textContent='−'; minus.style.background='#c0392b'; minus.onclick = ()=> removeOne(id);
    const rem = document.createElement('button'); rem.textContent='Remove'; rem.style.background='#7f8c8d'; rem.onclick = ()=> removeAll(id);
    right.appendChild(count); right.appendChild(plus); right.appendChild(minus); right.appendChild(rem);
    row.appendChild(left); row.appendChild(right); area.appendChild(row);
  });
  document.getElementById('deckCount').textContent = total + ' cards';
  updateJsonArea();
}

function addToDeck(card){
  const enforce4 = document.getElementById('fourLimit').checked;
  const id = card.id || ('local:' + card.name);
  if (!deckMap[id]) { deckMap[id] = { card: { id:id, name:card.name, type_line: card.type_line||'', image_uris: card.image_uris||null }, count:0 }; deckOrder.push(id); }
  const cur = deckMap[id].count || 0;
  if (enforce4 && cur >= 4) { alert('4-of limit reached for this card.'); return; }
  deckMap[id].count = cur + 1; saveDeck();
}

function removeOne(id){
  if (!deckMap[id]) return;
  deckMap[id].count -= 1;
  if (deckMap[id].count <= 0) { delete deckMap[id]; deckOrder = deckOrder.filter(x=>x!==id); }
  saveDeck();
}

function removeAll(id){ if (!deckMap[id]) return; delete deckMap[id]; deckOrder = deckOrder.filter(x=>x!==id); saveDeck(); }

function updateJsonArea(){
  const arr = deckOrder.map(id=> { const e = deckMap[id]; return { id:e.card.id, name:e.card.name, count:e.count, type_line:e.card.type_line||'', image_uris:e.card.image_uris||null }; });
  document.getElementById('jsonArea').value = JSON.stringify({deck:arr}, null, 2);
}

// Utils
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

// Fetch with fallback
async function fetchJsonWithFallback(url){
  try {
    const r = await fetch(url);
    if (!r.ok) throw new Error('Direct fetch failed: ' + r.status);
    return await r.json();
  } catch(err){
    console.warn('Direct fetch failed, trying proxy:', err);
    const prox = CORS_PROXY + encodeURIComponent(url);
    const r2 = await fetch(prox);
    if (!r2.ok) throw new Error('Proxy fetch failed: ' + r2.status);
    return await r2.json();
  }
}

// Scryfall calls
async function scrySearch(q, page=1){
  const encoded = encodeURIComponent(q) + `&page=${page}`;
  const url = SRY_BASE + encoded;
  return await fetchJsonWithFallback(url);
}
async function scryCardById(id){ const url = 'https://api.scryfall.com/cards/' + encodeURIComponent(id); return await fetchJsonWithFallback(url); }

// Filtering helper: returns true if card matches selected filters
function cardMatchesFilters(card, filters){
  // supertype (Legendary, Basic, Snow) -> check presence in type_line
  if (filters.supertypes.length){
    const typeLine = (card.type_line || '').toLowerCase();
    const hasAll = filters.supertypes.every(s => typeLine.includes(s.toLowerCase()));
    if (!hasAll) return false;
  }
  // type (Creature etc)
  if (filters.type){
    if (!((card.type_line||'').toLowerCase().includes(filters.type.toLowerCase()))) return false;
  }
  // subtype: split type_line at '—' and check right side contains substring
  if (filters.subtype){
    const tl = card.type_line || '';
    const parts = tl.split('—');
    const subs = (parts[1] || '').toLowerCase();
    if (!subs.includes(filters.subtype.toLowerCase())) return false;
  }
  // colors: require card.colors include all selected
  if (filters.colors.length){
    const c = card.colors || []; // array of letters like ['R','G']
    // if card has no colors and user selected colors -> fail
    const allPresent = filters.colors.every(ch => c.includes(ch));
    if (!allPresent) return false;
  }
  // format: use card.legalities[format] === 'legal'
  if (filters.format){
    const leg = card.legalities && card.legalities[filters.format];
    if (leg !== 'legal') return false;
  }
  return true;
}

// Build filters object from UI
function gatherFilters(){
  const sups = Array.from(document.querySelectorAll('.suptype:checked')).map(i=>i.value);
  const type = document.getElementById('typeSelect').value || '';
  const subtype = document.getElementById('subtypeInput').value.trim();
  const colors = Array.from(document.querySelectorAll('.colorChk:checked')).map(c=>c.value);
  const format = document.getElementById('formatSelect').value || '';
  return { supertypes: sups, type: type, subtype: subtype, colors: colors, format: format };
}

// Search flow: fetch page, filter client-side, render
const resultsDiv = document.getElementById('results');
const searchInfo = document.getElementById('searchInfo');

async function doSearchRaw(q, page=1){
  // If q empty, use a broad single-letter 'a' (Scryfall requires something), plus page
  const query = q && q.trim().length ? q.trim() : 'a';
  return await scrySearch(query, page);
}

async function doSearch(q, page=1){
  resultsDiv.innerHTML = '<div class="muted">Searching…</div>';
  searchInfo.textContent = '';
  try {
    const data = await doSearchRaw(q, page);
    if (data.object === 'error') { resultsDiv.innerHTML = `<div class="muted">Scryfall error: ${escapeHtml(data.details||'unknown')}</div>`; return; }
    const rawEntries = data.data || [];
    // filter them client-side according to UI filters
    const filters = gatherFilters();
    const filtered = rawEntries.filter(card => cardMatchesFilters(card, filters));
    renderResults(filtered, q, page, data.has_more, data.total_cards);
  } catch(e){
    resultsDiv.innerHTML = `<div class="muted">Search failed: ${escapeHtml(e.message)}</div>`;
    console.error(e);
  }
}

function renderResults(entries, q, page, has_more, total){
  resultsDiv.innerHTML = '';
  if (!entries.length){ resultsDiv.innerHTML = '<div class="muted">No results (try changing filters or search term)</div>'; searchInfo.textContent = ''; return; }
  const limit = Math.min(entries.length, MAX_RESULTS);
  for (let i=0;i<limit;i++){
    const c = entries[i];
    const row = document.createElement('div'); row.className='result';
    const thumb = document.createElement('div'); thumb.className='thumb'; thumb.textContent = (c.set||'').toUpperCase();
    const meta = document.createElement('div'); meta.className='meta';
    meta.innerHTML = `<strong>${escapeHtml(c.name)}</strong><small>${escapeHtml(c.type_line||'')} • ${escapeHtml(c.rarity||'')}</small>`;
    const actions = document.createElement('div'); actions.style.display='flex'; actions.style.gap='6px';
    const previewBtn = document.createElement('button'); previewBtn.textContent='Preview'; previewBtn.onclick = ()=> loadAndPreview(c.id);
    const addBtn = document.createElement('button'); addBtn.textContent='Add'; addBtn.onclick = async ()=>{
      const full = await scryCardById(c.id);
      addToDeck(full);
    };
    actions.appendChild(previewBtn); actions.appendChild(addBtn);
    row.appendChild(thumb); row.appendChild(meta); row.appendChild(actions);
    resultsDiv.appendChild(row);
  }
  // paging
  const nav = document.createElement('div'); nav.style.display='flex'; nav.style.justifyContent='space-between'; nav.style.marginTop='8px';
  const prev = document.createElement('button'); prev.textContent='Prev'; prev.disabled = false; prev.onclick = ()=> doSearch(document.getElementById('q').value.trim(), Math.max(1, (Number(prev.dataset.page)||1)-1));
  const next = document.createElement('button'); next.textContent='Next'; next.disabled = !has_more;
  // we can't compute page easily here without passing, so use local event closure
  prev.onclick = ()=> doSearch(document.getElementById('q').value.trim(), 1); // simplifies: Prev resets to page 1
  next.onclick = ()=> {
    // Scryfall returns has_more and we don't have next page token here; easiest is to increment by 1 based on a stored lastPage
    lastPage = (lastPage || 1) + 1; doSearch(document.getElementById('q').value.trim(), lastPage);
  };
  nav.appendChild(prev); nav.appendChild(next);
  resultsDiv.appendChild(nav);

  searchInfo.textContent = `${total || entries.length} results (filtered)`;
}

// Preview
async function loadAndPreview(id){
  try {
    const card = await scryCardById(id);
    let img = '';
    if (card.image_uris && card.image_uris.normal) img = card.image_uris.normal;
    else if (card.image_uris && card.image_uris.large) img = card.image_uris.large;
    else if (card.card_faces && card.card_faces[0] && card.card_faces[0].image_uris) img = card.card_faces[0].image_uris.normal;
    document.getElementById('previewTitle').textContent = card.name;
    document.getElementById('previewType').textContent = card.type_line || '';
    const imgEl = document.getElementById('previewImg'), ph = document.getElementById('previewPlaceholder');
    if (img){ imgEl.src = img; imgEl.style.display = 'block'; ph.style.display = 'none'; } else { imgEl.style.display='none'; ph.style.display='block'; ph.textContent='No image available'; }
    // preload into deckMap but not counted until add
    const idk = card.id || ('local:' + card.name);
    if (!deckMap[idk]) deckMap[idk] = { card: { id:idk, name:card.name, type_line:card.type_line||'', image_uris:card.image_uris||null }, count:0 };
    else { deckMap[idk].card.image_uris = deckMap[idk].card.image_uris || card.image_uris || null; deckMap[idk].card.type_line = deckMap[idk].card.type_line || card.type_line || ''; }
  } catch(e){ alert('Preview failed: ' + e.message); console.error(e); }
}

// Import/Export
document.getElementById('exportBtn').addEventListener('click', ()=>{
  const arr = deckOrder.map(id=>{ const e = deckMap[id]; return { id:e.card.id, name:e.card.name, count:e.count, type_line:e.card.type_line||'' }; });
  const blob = new Blob([JSON.stringify({deck:arr}, null,2)], {type:'application/json'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'deck.json'; a.click(); URL.revokeObjectURL(a.href);
});
document.getElementById('importBtn').addEventListener('click', ()=>{
  const raw = prompt('Paste deck JSON ({"deck":[...]})');
  if (!raw) return;
  try {
    const obj = JSON.parse(raw);
    if (!Array.isArray(obj.deck)) throw new Error('Invalid deck JSON');
    deckMap = {}; deckOrder = [];
    obj.deck.forEach(it=>{
      const id = it.id || ('local:' + it.name);
      deckMap[id] = { card: { id:id, name:it.name, type_line: it.type_line || '', image_uris: it.image_uris || null }, count: it.count || 1 };
      deckOrder.push(id);
    });
    saveDeck(); alert('Imported deck applied.');
  } catch(e){ alert('Import error: ' + e.message); }
});
document.getElementById('applyImport').addEventListener('click', ()=>{
  try {
    const parsed = JSON.parse(document.getElementById('jsonArea').value);
    if (!Array.isArray(parsed.deck)) throw new Error('JSON must include { deck: [...] }');
    deckMap = {}; deckOrder = [];
    parsed.deck.forEach(it=>{ const id = it.id || ('local:' + it.name); deckMap[id] = { card: { id:id, name:it.name, type_line:it.type_line||'', image_uris: it.image_uris||null }, count: it.count || 1 }; deckOrder.push(id); });
    saveDeck(); alert('Deck applied from text area.');
  } catch(e){ alert('Apply import error: ' + e.message); }
});
document.getElementById('copyExport').addEventListener('click', ()=>{ document.getElementById('jsonArea').select(); document.execCommand('copy'); alert('Deck JSON copied to clipboard.'); });

// Filters UI
let filtersVisible = false;
document.getElementById('toggleFilters').addEventListener('click', ()=>{
  filtersVisible = !filtersVisible;
  document.getElementById('filterPanel').style.display = filtersVisible ? 'block' : 'none';
  document.getElementById('toggleFilters').textContent = filtersVisible ? 'Hide Advanced Filters' : 'Show Advanced Filters';
});

// Apply / clear filters events
document.getElementById('applyFilters').addEventListener('click', ()=> { lastPage = 1; doSearch(document.getElementById('q').value.trim(), 1); });
document.getElementById('clearFilters').addEventListener('click', ()=>{
  document.querySelectorAll('.suptype').forEach(i=>i.checked=false);
  document.getElementById('typeSelect').value = '';
  document.getElementById('subtypeInput').value = '';
  document.querySelectorAll('.colorChk').forEach(i=>i.checked=false);
  document.getElementById('formatSelect').value = '';
});

// Search triggers
document.getElementById('searchBtn').addEventListener('click', ()=> { lastPage = 1; doSearch(document.getElementById('q').value.trim(), 1); });
document.getElementById('q').addEventListener('keydown', (e)=> { if (e.key === 'Enter') { lastPage = 1; doSearch(document.getElementById('q').value.trim(), 1); } });

// Simple paging state
let lastPage = 1;

// Init
loadDeck(); renderDeck(); updateJsonArea();
</script>
</body>
</html>

</script>
</body>
</html>
